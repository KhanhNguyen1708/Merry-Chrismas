<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#0d0f1f" />
    <title>Magic Christmas - Final Clean</title>

    <!-- Festive fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Merriweather:wght@400;700;900&family=Mountains+of+Christmas:wght@700&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      :root {
        --gold: #ffd700;
        --deep-red: #7b1f1f;
        --bright-red: #e53935;
        --bg1: #02030a;
        --bg2: #0d0f1f;
        --glow: rgba(255, 215, 0, 0.35);
      }
      body {
        margin: 0;
        overflow: hidden;
        /* Smoother layered dark gradient */
        background:
          radial-gradient(1200px 700px at 50% 18%, rgba(13, 15, 31, 0.95), rgba(2, 3, 10, 0.95) 70%),
          linear-gradient(180deg, rgba(10, 12, 24, 0.85) 0%, rgba(2, 3, 10, 0.95) 100%);
        font-family: "Merriweather", "Poppins", "Segoe UI", sans-serif;
        color: #fff;
      }
      #canvas-container {
        width: 100%;
        height: var(--app-height, 100vh);
        display: block;
        position: relative;
      }
      /* Animated aurora behind the canvas */
      #canvas-container::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 0;
        background:
          radial-gradient(80% 100% at 15% 10%, rgba(0, 200, 230, 0.10), rgba(0, 0, 0, 0) 60%),
          radial-gradient(70% 90% at 85% 15%, rgba(160, 80, 220, 0.09), rgba(0, 0, 0, 0) 55%),
          conic-gradient(from 210deg at 50% 50%, rgba(0,0,0,0), rgba(30, 210, 140, 0.08), rgba(0,0,0,0) 25%);
        filter: blur(12px);
        opacity: 0; /* hidden until START */
        transition: opacity 1200ms ease, filter 800ms ease;
        background-size: 140% 140%, 150% 150%, 200% 200%;
        animation: auroraShift 32s ease-in-out infinite;
      }
      /* Reveal aurora after start */
      .started #canvas-container::before { opacity: 0.6; }
      /* Pause/soften aurora when performance is low */
      .lowperf #canvas-container::before {
        animation-play-state: paused;
        opacity: 0.35;
        filter: blur(8px);
      }
      /* Vignette overlay for depth */
      #canvas-container::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(60% 50% at 50% 50%, rgba(0,0,0,0) 30%, rgba(0,0,0,0.35) 75%, rgba(0,0,0,0.65) 100%),
          repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0 2px, rgba(0,0,0,0.02) 2px 4px);
        background-blend-mode: normal, overlay;
      
      }

      /* Keep canvas above decorative overlays */
      #canvas-container canvas {
        position: relative;
        z-index: 1;
      }

      @keyframes auroraShift {
        0% { background-position: 0% 0%, 100% 0%, 0% 0%; }
        50% { background-position: 50% 20%, 60% 30%, 100% 100%; }
        100% { background-position: 0% 0%, 100% 0%, 0% 0%; }
      }

      #ui-layer {
        position: absolute;
        bottom: calc(60px + env(safe-area-inset-bottom, 0px));
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 100;
      }
      /* Small mute button - refined styling */
      #mute-btn {
        position: fixed;
        bottom: calc(12px + env(safe-area-inset-bottom, 0px));
        right: calc(12px + env(safe-area-inset-right, 0px));
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 2px solid var(--gold);
        background: radial-gradient(circle at 30% 30%, rgba(255,215,0,0.22), rgba(0,0,0,0.65));
        backdrop-filter: blur(2px);
        color: var(--gold);
        font-size: 18px;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 16px var(--glow), inset 0 0 8px rgba(255, 255, 255, 0.08);
        pointer-events: auto;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.3s ease;
      }
      /* Volume slider */
      #volume-slider {
        position: fixed;
        bottom: calc(54px + env(safe-area-inset-bottom, 0px)); /* just above mute button */
        right: calc(12px + env(safe-area-inset-right, 0px));
        width: clamp(120px, 30vw, 180px);
        pointer-events: auto;
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: rgba(255,255,255,0.22);
        box-shadow: 0 0 12px var(--glow), inset 0 0 4px rgba(0,0,0,0.35);
        outline: none;
      }
      #volume-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--gold);
        box-shadow: 0 0 8px var(--glow);
        cursor: pointer;
      }
      #volume-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--gold);
        box-shadow: 0 0 8px var(--glow);
        cursor: pointer;
      }
      #mute-btn:hover {
        transform: translateY(-1px) scale(1.04);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.12);
      }
      #mute-btn:active {
        transform: scale(0.97);
      }
      #mute-btn:focus-visible {
        outline: 3px solid rgba(255, 215, 0, 0.6);
        outline-offset: 2px;
      }

      .guide {
        color: rgba(255, 255, 255, 0.75);
        font-size: 14px;
        margin-bottom: 16px;
        text-shadow: 0 2px 6px rgba(0,0,0,0.7);
        animation: fadeUp 800ms ease both;
      }
      /* Bottom-centered guide line */
      #bottom-guide {
        position: fixed;
        left: 50%;
        bottom: calc(18px + env(safe-area-inset-bottom, 0px));
        transform: translateX(-50%);
        margin-bottom: 0;
        text-align: center;
        z-index: 120;
        pointer-events: none;
      }
      /* Larger, centered pre-start message */
      #preStart-msg {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: 34px;
        font-family: "Dancing Script", cursive;
        color: rgba(255,255,255,0.95);
        text-shadow: 0 6px 18px rgba(0,0,0,0.6), 0 0 24px rgba(255,215,0,0.25);
        z-index: 150;
        pointer-events: none;
        animation: fadeUp 1000ms ease both;
      }

      button {
        pointer-events: auto;
        cursor: pointer;
        background: linear-gradient(to bottom, var(--bright-red), var(--deep-red));
        color: #fff;
        border: 2px solid var(--gold);
        padding: 15px 50px;
        border-radius: 30px;
        font-family: "Merriweather", serif;
        font-weight: 700;
        font-size: 16px;
        box-shadow: 0 8px 30px rgba(255, 0, 0, 0.35), 0 0 16px var(--glow);
        animation: pulse 1.8s infinite;
        position: relative;
        overflow: hidden;
        transition: transform 0.15s ease, box-shadow 0.25s ease;
      }
      button::before {
        content: "";
        position: absolute;
        top: 0;
        left: -120%;
        width: 60%;
        height: 100%;
        background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.25) 50%, rgba(255,255,255,0) 100%);
        transform: skewX(-20deg);
        transition: left 0.6s ease;
      }
      button:hover::before { left: 130%; }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }
      @keyframes fadeUp {
        from { opacity: 0; transform: translate(-50%, calc(-50% + 8px)); }
        to { opacity: 1; transform: translate(-50%, -50%); }
      }

    
      #copyright {
        position: absolute;
        bottom: 10px;
        right: 15px;
        color: rgba(255, 255, 255, 0.3);
        font-size: 12px;
        z-index: 100;
        font-family: sans-serif;
        pointer-events: none;
        font-style: italic;
      }

      #error-log {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        color: red;
        background: rgba(0, 0, 0, 0.8);
        z-index: 999;
        padding: 10px;
      }

      /* DOB input overlay */
      #dob-overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 210;
        pointer-events: none;
      }
      /* Prevent page scroll when modal shown */
      .modal-open { overflow: hidden; height: 100%; }
      #dob-overlay .card {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.65);
        backdrop-filter: blur(6px);
        border: 2px solid var(--gold);
        border-radius: 12px;
        padding: 18px 22px;
        color: #fff;
        text-align: center;
        box-shadow: 0 0 30px var(--glow);
        animation: popIn 350ms ease both;
      }
      #dob-overlay .title {
        font-weight: 700;
        margin-bottom: 10px;
        font-family: "Merriweather", serif;
      }
      #dob-date {
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #555;
        background: #111;
        color: #fff;
        font-size: 16px; /* Prevent iOS auto-zoom on focus */
      }
      #dob-actions {
        margin-top: 12px;
        display: flex;
        gap: 10px;
        justify-content: center;
      }
      .btn {
        background: var(--gold);
        color: var(--deep-red);
        border: none;
        padding: 8px 14px;
        border-radius: 8px;
        font-weight: 700;
        cursor: pointer;
      }
      /* Gift message overlay */
      #gift-message {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 200;
        pointer-events: none;
      }
      #gift-message .card {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(6px);
        border: 2px solid var(--gold);
        border-radius: 12px;
        padding: 18px 22px;
        max-width: 80%;
        color: #fff;
        text-align: center;
        box-shadow: 0 0 30px var(--glow);
        animation: popIn 280ms ease both;
      }
      #gift-message .text {
        font-size: 18px;
        margin-bottom: 12px;
        line-height: 1.4;
        font-family: "Merriweather", serif;
      }
      #gift-close {
        background: var(--gold);
        color: var(--deep-red);
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        font-weight: 700;
        cursor: pointer;
      }
      @keyframes popIn {
        from { opacity: 0; transform: translateY(8px) scale(0.96); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }

      /* Small-screen tweaks */
      @media (max-width: 480px) {
        #preStart-msg { font-size: 28px; }
        .guide { font-size: 12px; }
        button { padding: 12px 28px; font-size: 14px; }
        #mute-btn { width: 30px; height: 30px; bottom: calc(10px + env(safe-area-inset-bottom, 0px)); right: calc(10px + env(safe-area-inset-right, 0px)); }
        #volume-slider { width: clamp(100px, 40vw, 140px); bottom: calc(46px + env(safe-area-inset-bottom, 0px)); right: calc(10px + env(safe-area-inset-right, 0px)); }
      }
    </style>
  </head>
  <body>
    <div id="error-log"></div>

   
    <div id="ui-layer">
   
      <div class="guide" id="preStart-msg">Ch√∫c b·∫°n c√≥ m·ªôt Gi√°ng Sinh nhi·ªám m√†u ‚ú®</div>
      <div class="guide" id="bottom-guide">H√£y t√¨m nh·ªØng ƒëi·ªÅu th√∫ v·ªã sau khi b·∫•m n√∫t ‚ùÑÔ∏è</div>
      <button id="btnStart" onclick="startSystem()">B·∫Øt ƒê·∫ßu</button>
      <button id="mute-btn" title="T·∫Øt/B·∫≠t ti·∫øng" aria-label="T·∫Øt/B·∫≠t ti·∫øng">üîä</button>
      <input id="volume-slider" type="range" min="0" max="100" value="70" aria-label="√Çm l∆∞·ª£ng" />
    </div>

 

    <div id="canvas-container"></div>
    <div id="gift-message">
      <div class="card">
        <div class="text" id="gift-text">Ch√∫c m·ª´ng Gi√°ng Sinh an l√†nh!</div>
        <button id="gift-close">ƒê√≥ng</button>
      </div>
    </div>
    <div id="dob-overlay">
      <div class="card">
        <div class="title">Nh·∫≠p t√™n ho·∫∑c ng√†y sinh (dd/mm)</div>
        <input
          type="text"
          id="dob-date"
          placeholder="T√™n ho·∫∑c dd/mm"
          inputmode="text"
        />
        <div id="dob-actions">
          <button class="btn" id="dob-confirm">X√°c nh·∫≠n</button>
          <button class="btn" id="dob-cancel">H·ªßy</button>
        </div>
      </div>
    </div>

    <script>
      
      let MUSIC_PLAYLIST = [];
      let musicIndex = 0;
      let userConsentedToAudio = false;
      const SANTA_SOUND = "./MUSIC_PLAYLIST/Santa sound.mp3";

      const DEFAULT_VOLUME = 0.7;
      let bgMusic = new Audio();
      bgMusic.loop = true;
      bgMusic.volume = DEFAULT_VOLUME;
      let isPlayingSanta = false;
      let pausedByVisibility = false;
      let lastVolume = DEFAULT_VOLUME;

      function loadPlaylistFromFile() {
        return fetch("./music.txt")
          .then((res) => res.text())
          .then((text) => {
            MUSIC_PLAYLIST = text
              .split(/\r?\n/)
              .map((line) => line.replace(/^\uFEFF/, '').trim())
              .filter(Boolean)
              .filter((line) => /\.mp3(\?.*)?$/i.test(line));

            if (MUSIC_PLAYLIST.length === 0) {
              throw new Error("Playlist r·ªóng");
            }
          });
      }

      

      function setAudioSource(url) {
        try {
          bgMusic.src = encodeURI(url);
        } catch {
          bgMusic.src = url;
        }
      }

      function playRandomSong() {
        if (!MUSIC_PLAYLIST || MUSIC_PLAYLIST.length === 0) return;

        let next = musicIndex;
        if (MUSIC_PLAYLIST.length > 1) {
          do {
            next = Math.floor(Math.random() * MUSIC_PLAYLIST.length);
          } while (next === musicIndex);
        } else {
          next = 0;
        }

        musicIndex = next;
        setAudioSource(MUSIC_PLAYLIST[musicIndex]);
        bgMusic.play().catch(() => {});
      }

      function playSantaSound() {
        try { bgMusic.pause(); } catch {}
        setAudioSource(SANTA_SOUND);
        bgMusic.loop = false;
        isPlayingSanta = true;
        bgMusic.play().catch(() => {});
      }

      function triggerTreeBurst(durationMs = 7000) {
        // Switch to EXPLODE effect temporarily, then return to TREE
        state = "EXPLODE";
        setTimeout(() => {
          state = "TREE";
        }, Math.max(1000, durationMs));
      }

      function triggerHeart(durationMs = 5000) {
        // Switch to HEART layout temporarily, then return to TREE
        state = "HEART";
        setTimeout(() => {
          state = "TREE";
        }, Math.max(1000, durationMs));
      }

      const loader = new THREE.TextureLoader();
      // Load an image and automatically remove a solid background (detected from corners)
      
      const photoFiles = [
        "./santa_claus_PNG38508.png",
        "./image2.jpeg",
        "./image3.jpeg",
        "./image4.jpeg",
        "./image5.jpeg",
      ];
      const photoTextures = [];
      function loadPhotoTextures() {
        // Load Santa image as-is (no background removal)
        photoTextures[0] = loader.load(photoFiles[0]);
        for (let i = 1; i < photoFiles.length; i++) {
          photoTextures[i] = loader.load(photoFiles[i]);
        }
      }

      function createCustomTexture(type) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        const cx = 64,
          cy = 64;

        if (type === "gold_glow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
          grd.addColorStop(0, "#ffffff");
          grd.addColorStop(0.25, "#fff6d1");
          grd.addColorStop(0.55, "#ffd36b");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "red_light") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
          grd.addColorStop(0, "#ffdddd");
          grd.addColorStop(0.35, "#e53935");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "gift_red") {
          ctx.fillStyle = "#c62828"; // richer crimson
          ctx.fillRect(20, 20, 88, 88);
          ctx.fillStyle = "#f1c40f"; // warm gold ribbon
          ctx.fillRect(54, 20, 20, 88);
          ctx.fillRect(20, 54, 88, 20);
          ctx.strokeStyle = "rgba(0,0,0,0.25)";
          ctx.lineWidth = 2;
          ctx.strokeRect(20, 20, 88, 88);
        } else if (type === "gift_green") {
          ctx.fillStyle = "#1e7f5a"; // deeper emerald
          ctx.fillRect(20, 20, 88, 88);
          ctx.fillStyle = "#f1c40f";
          ctx.fillRect(54, 20, 20, 88);
          ctx.fillRect(20, 54, 88, 20);
          ctx.strokeStyle = "rgba(0,0,0,0.25)";
          ctx.lineWidth = 2;
          ctx.strokeRect(20, 20, 88, 88);
        } else if (type === "snowflake") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
          grd.addColorStop(0.0, "rgba(255,255,255,0.95)");
          grd.addColorStop(0.5, "rgba(240,240,255,0.55)");
          grd.addColorStop(1.0, "rgba(255,255,255,0.0)");
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(cx, cy, 50, 0, Math.PI * 2);
          ctx.fill();
        } else if (type === "flame") {
          const grd = ctx.createRadialGradient(cx, cy + 10, 0, cx, cy, 50);
          grd.addColorStop(0.0, "rgba(255,245,210,0.95)");
          grd.addColorStop(0.5, "rgba(255,170,60,0.85)");
          grd.addColorStop(1.0, "rgba(255,90,30,0.0)");
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(cx, cy, 45, 0, Math.PI * 2);
          ctx.fill();
        } else if (type === "santa") {
          // Simple Santa + sleigh stylized drawing
          ctx.clearRect(0, 0, 128, 128);
          // Sleigh body
          ctx.fillStyle = "#B22222";
          ctx.fillRect(20, 72, 60, 18);
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(54, 62, 26, 10);
          // Runners
          ctx.strokeStyle = "#FFD700";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(22, 92);
          ctx.quadraticCurveTo(40, 104, 78, 92);
          ctx.stroke();
          // Santa head
          ctx.fillStyle = "#FFE0BD";
          ctx.beginPath();
          ctx.arc(70, 55, 10, 0, Math.PI * 2);
          ctx.fill();
          // Hat
          ctx.fillStyle = "#FF0000";
          ctx.beginPath();
          ctx.moveTo(60, 48);
          ctx.lineTo(84, 48);
          ctx.lineTo(72, 34);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.arc(72, 34, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(60, 48, 24, 4);
          // Beard
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.arc(70, 60, 8, 0, Math.PI * 2);
          ctx.fill();
          // Gift on sleigh
          ctx.fillStyle = "#2E8B57";
          ctx.fillRect(28, 62, 12, 12);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(33, 62, 2, 12);
          ctx.fillRect(28, 67, 12, 2);
        }
        return new THREE.CanvasTexture(canvas);
      }

      const textures = {
        gold: createCustomTexture("gold_glow"),
        red: createCustomTexture("red_light"),
        gift: createCustomTexture("gift_red"),
        giftGreen: createCustomTexture("gift_green"),
        snow: createCustomTexture("snowflake"),
        flame: createCustomTexture("flame"),
        santa: createCustomTexture("santa"),
      };

      let MESSAGES = [
        "Ch√∫c b·∫°n Gi√°ng Sinh an l√†nh v√† ·∫•m √°p!",
        "Merry Christmas! Lu√¥n vui v·∫ª v√† h·∫°nh ph√∫c nh√©!",
        "Gi√°ng Sinh di·ªáu k·ª≥, ƒëi·ªÅu ∆∞·ªõc th√†nh hi·ªán th·ª±c!",
        "G·ª≠i b·∫°n th·∫≠t nhi·ªÅu y√™u th∆∞∆°ng m√πa Noel!",
        "Ch√∫c s·ª©c kh·ªèe, b√¨nh an v√† tr√†n ƒë·∫ßy ni·ªÅm vui!",
      ];

      const CONFIG = {
        goldCount: 2000,
        redCount: 300,
        giftCount: 150,
        explodeRadius: 65,
        photoOrbitRadius: 25,
        treeHeight: 70,
        treeBaseRadius: 35,
        snowCount: 700,
      };
      // Device profile detection
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 600;
      function applyDeviceProfile() {
        if (isMobile) {
          CONFIG.goldCount = 1400;
          CONFIG.redCount = 220;
          CONFIG.giftCount = 100;
          CONFIG.photoOrbitRadius = 22;
          CONFIG.snowCount = 420;
        } else {
          CONFIG.goldCount = 2000;
          CONFIG.redCount = 300;
          CONFIG.giftCount = 150;
          CONFIG.photoOrbitRadius = 25;
          CONFIG.snowCount = 700;
        }
      }

      let scene, camera, renderer;
      let groupGold, groupRed, groupGift;
      let photoMeshes = [];
      let titleMesh, starMesh;

      let state = "TREE";
      let selectedIndex = 0;
      let currentRotY = 0;
      let rotVelocity = 0;
      let isDragging = false;
      let lastPointerX = 0;

      let snowPoints,
        snowVelocities = [],
        snowGeo;
      let giftSprites = [],
        giftVel = [];
      let fireplaceGroup = null,
        fireplaceHit = null,
        flameSprite = null;
      let santaSprite = null,
        santaActive = false,
        santaSpeed = 0.12,
        santaPhase = 0,
        nextSantaIn = 10;
      let lastTime = 0;
      // Dynamic performance tuning
      let initialPixelRatio = 1;
      let currentPixelRatio = 1;
      let fpsAccum = 0;
      let fpsCount = 0;
      let lastFpsAdjust = 0;
      let frameCounter = 0;
      const raycaster = new THREE.Raycaster();
      const ndc = new THREE.Vector2();
      let downX = 0,
        downY = 0,
        upX = 0,
        upY = 0;

      
      function init3D() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        const targetPR = Math.min(window.devicePixelRatio || 1, isMobile ? 1.5 : 2);
        initialPixelRatio = targetPR;
        currentPixelRatio = targetPR;
        renderer.setPixelRatio(currentPixelRatio);
        container.appendChild(renderer.domElement);

        groupGold = createParticleSystem("gold", CONFIG.goldCount, 2.0);
        groupRed = createParticleSystem("red", CONFIG.redCount, 3.5);
        groupGift = createParticleSystem("gift", CONFIG.giftCount, 3.0);

        createPhotos();
        createDecorations();
        createSnow();
        createFallingGifts();
        createFireplace();
        createSanta();

        const el = renderer.domElement;
        el.style.touchAction = "none";
        el.addEventListener("pointerdown", (e) => {
          isDragging = true;
          lastPointerX = e.clientX;
          downX = e.clientX;
          downY = e.clientY;
        });
        window.addEventListener("pointermove", (e) => {
          if (!isDragging) return;
          const dx = e.clientX - lastPointerX;
          lastPointerX = e.clientX;
          rotVelocity = (dx / window.innerWidth) * 6.0;
        });
        window.addEventListener("pointerup", (e) => {
          isDragging = false;
          upX = e.clientX;
          upY = e.clientY;
          const moved = Math.hypot(upX - downX, upY - downY);
          if (moved < 6) handleTap(e);
        });
        window.addEventListener("pointercancel", () => {
          isDragging = false;
        });
        animate();
      }

      function createParticleSystem(type, count, size) {
        const pPositions = [];
        const pExplodeTargets = [];
        const pTreeTargets = [];
        const pHeartTargets = [];
        const sizes = [];
        const phases = [];

        for (let i = 0; i < count; i++) {
          
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          let radiusRatio =
            type === "gold"
              ? Math.sqrt(Math.random())
              : 0.9 + Math.random() * 0.1;
          const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
          const r = maxR * radiusRatio;
          const theta = Math.random() * Math.PI * 2;
          pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

          
          const u = Math.random();
          const v = Math.random();
          const phi = Math.acos(2 * v - 1);
          const lam = 2 * Math.PI * u;
          let radMult = type === "gift" ? 1.2 : 1.0;
          const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
          pExplodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.cos(phi)
          );

          
          const tHeart = Math.random() * Math.PI * 2;
          let hx = 16 * Math.pow(Math.sin(tHeart), 3);
          let hy =
            13 * Math.cos(tHeart) -
            5 * Math.cos(2 * tHeart) -
            2 * Math.cos(3 * tHeart) -
            Math.cos(4 * tHeart);

          const rFill = Math.pow(Math.random(), 0.3); 
          hx *= rFill;
          hy *= rFill;
          let hz = (Math.random() - 0.5) * 8 * rFill;

          const noise = 1.0;
          hx += (Math.random() - 0.5) * noise;
          hy += (Math.random() - 0.5) * noise;
          hz += (Math.random() - 0.5) * noise;

          const scaleH = 2.2;
          pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz);

         
          pPositions.push(
            pTreeTargets[i * 3],
            pTreeTargets[i * 3 + 1],
            pTreeTargets[i * 3 + 2]
          );
          sizes.push(size);
          phases.push(Math.random() * Math.PI * 2);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(pPositions, 3)
        );
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

       
        const colors = new Float32Array(count * 3);
        const baseColor = new THREE.Color();
        if (type === "gold") baseColor.setHex(0xffd36b); // refined warm gold
        else if (type === "red") baseColor.setHex(0xe53935); // ruby red
        else baseColor.setHex(0xffffff);

        for (let i = 0; i < count; i++) {
          colors[i * 3] = baseColor.r;
          colors[i * 3 + 1] = baseColor.g;
          colors[i * 3 + 2] = baseColor.b;
        }
        geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        geo.userData = {
          tree: pTreeTargets,
          explode: pExplodeTargets,
          heart: pHeartTargets,
          phases: phases,
          baseColor: baseColor,
          baseSize: size,
        };

        const mat = new THREE.PointsMaterial({
          size: size,
          map: textures[type],
          transparent: true,
          opacity: 1.0,
          vertexColors: true,
          blending:
            type === "gift" ? THREE.NormalBlending : THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      function createPhotos() {
        const geo = new THREE.PlaneGeometry(8, 8);
        const borderGeo = new THREE.PlaneGeometry(9, 9);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });

        for (let i = 0; i < 5; i++) {
          const mat = new THREE.MeshBasicMaterial({
            map: photoTextures[i],
            side: THREE.DoubleSide,
            transparent: true,
          });
          const mesh = new THREE.Mesh(geo, mat);
          // Only add a border for non-Santa photos
          if (i !== 0) {
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.1;
            mesh.add(border);
          }
          // Make Santa (index 0) much larger than other photos
          mesh.userData.scaleMul = i === 0 ? 3.0 : 1.0;
          mesh.visible = false;
          mesh.scale.set(0, 0, 0);
          scene.add(mesh);
          photoMeshes.push(mesh);
        }
      }

      function createDecorations() {
        
        const canvas = document.createElement("canvas");
        canvas.width = 1024;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        ctx.font = 'bold 100px "Mountains of Christmas"';
        const textGrad = ctx.createLinearGradient(200, 0, 824, 0);
        textGrad.addColorStop(0, "#fff6d1");
        textGrad.addColorStop(0.5, "#ffd36b");
        textGrad.addColorStop(1, "#f5b64a");
        ctx.fillStyle = textGrad;
        ctx.textAlign = "center";
        ctx.shadowColor = "#ffd36b";
        ctx.shadowBlur = 30;
        ctx.fillText("MERRY CHRISTMAS", 512, 130);
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
        titleMesh.position.set(0, 50, 0);
        scene.add(titleMesh);

        
        const starCanvas = document.createElement("canvas");
        starCanvas.width = 128;
        starCanvas.height = 128;
        const sCtx = starCanvas.getContext("2d");
        const starGrad = sCtx.createRadialGradient(64, 64, 0, 64, 64, 52);
        starGrad.addColorStop(0, "#fff7d6");
        starGrad.addColorStop(0.5, "#ffd36b");
        starGrad.addColorStop(1, "rgba(255, 211, 107, 0.0)");
        sCtx.fillStyle = starGrad;
        sCtx.shadowColor = "#ffd36b";
        sCtx.shadowBlur = 24;
        sCtx.beginPath();
        const cx = 64,
          cy = 64,
          outer = 50,
          inner = 20;
        for (let i = 0; i < 5; i++) {
          sCtx.lineTo(
            cx + Math.cos(((18 + i * 72) / 180) * Math.PI) * outer,
            cy - Math.sin(((18 + i * 72) / 180) * Math.PI) * outer
          );
          sCtx.lineTo(
            cx + Math.cos(((54 + i * 72) / 180) * Math.PI) * inner,
            cy - Math.sin(((54 + i * 72) / 180) * Math.PI) * inner
          );
        }
        sCtx.closePath();
        sCtx.fill();
        const starTex = new THREE.CanvasTexture(starCanvas);
        const starMat = new THREE.MeshBasicMaterial({
          map: starTex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
        scene.add(starMesh);
      }

      function createSnow() {
        const count = CONFIG.snowCount;
        const positions = new Float32Array(count * 3);
        snowVelocities = new Float32Array(count);
        for (let i = 0; i < count; i++) {
          const x = (Math.random() - 0.5) * 160;
          const y = Math.random() * 120;
          const z = (Math.random() - 0.5) * 160;
          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;
          snowVelocities[i] = 0.15 + Math.random() * 0.25;
        }
        snowGeo = new THREE.BufferGeometry();
        snowGeo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        const mat = new THREE.PointsMaterial({
          size: 1.8,
          map: textures.snow,
          transparent: true,
          opacity: 0.9,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
          color: 0xffffff,
        });
        snowPoints = new THREE.Points(snowGeo, mat);
        scene.add(snowPoints);
      }

      function createFallingGifts() {
        const count = 8;
        for (let i = 0; i < count; i++) {
          const tex = chooseGiftTexture();
          const mat = new THREE.SpriteMaterial({
            map: tex,
            transparent: true,
            depthWrite: false,
          });
          const spr = new THREE.Sprite(mat);
          spr.scale.set(6, 6, 1);
          resetGift(spr, true);
          giftSprites.push(spr);
          // slower falling speed
          giftVel.push(0.12 + Math.random() * 0.18);
          scene.add(spr);
        }
      }

      function createFireplace() {
        fireplaceGroup = new THREE.Group();
        fireplaceGroup.position.set(32, -10, -8); // right, lower, behind the tree

        // Back panel (brick-like)
        const backCanvas = document.createElement("canvas");
        backCanvas.width = 256;
        backCanvas.height = 192;
        const bctx = backCanvas.getContext("2d");
        bctx.fillStyle = "#5A3427";
        bctx.fillRect(0, 0, 256, 192);
        bctx.fillStyle = "#8B4513";
        for (let y = 0; y < 192; y += 24) {
          const offset = (y / 24) % 2 === 0 ? 0 : 12;
          for (let x = offset; x < 256; x += 24) {
            bctx.fillRect(x, y, 22, 20);
          }
        }
        const backTex = new THREE.CanvasTexture(backCanvas);
        const backMat = new THREE.MeshBasicMaterial({ map: backTex });
        const backMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(22, 16),
          backMat
        );
        backMesh.position.set(0, 0, -0.5);
        fireplaceGroup.add(backMesh);

        // Opening
        const openMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const openMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(10, 8),
          openMat
        );
        openMesh.position.set(0, -1, 0);
        fireplaceGroup.add(openMesh);

        // Hearth/base
        const baseMat = new THREE.MeshBasicMaterial({ color: 0x4a2c21 });
        const baseMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(24, 3),
          baseMat
        );
        baseMesh.position.set(0, -8, 0);
        fireplaceGroup.add(baseMesh);

        // Flame sprite
        const flameMat = new THREE.SpriteMaterial({
          map: textures.flame,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          opacity: 0.9,
        });
        flameSprite = new THREE.Sprite(flameMat);
        flameSprite.scale.set(5, 7, 1);
        flameSprite.position.set(0, -2, 0.1);
        fireplaceGroup.add(flameSprite);

        // Clickable plane (transparent)
        const hitMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.0,
        });
        fireplaceHit = new THREE.Mesh(new THREE.PlaneGeometry(24, 18), hitMat);
        fireplaceHit.position.set(0, -1, 0.2);
        fireplaceGroup.add(fireplaceHit);

        scene.add(fireplaceGroup);
      }

      function createSanta() {
        const mat = new THREE.SpriteMaterial({
          map: textures.santa,
          transparent: true,
          depthWrite: false,
        });
        santaSprite = new THREE.Sprite(mat);
        santaSprite.scale.set(20, 12, 1);
        santaSprite.position.set(-90, 25, -12);
        santaSprite.visible = false;
        scene.add(santaSprite);
        santaPhase = Math.random() * Math.PI * 2;
        nextSantaIn = 8 + Math.random() * 12; // seconds
      }

      function resetGift(spr, initial = false) {
        const x = (Math.random() - 0.5) * 120;
        const z = (Math.random() - 0.5) * 80;
        const y = initial ? 30 + Math.random() * 90 : 90 + Math.random() * 40;
        spr.position.set(x, y, z);
        // Re-randomize color to maintain ~60% red / 40% green over time
        if (spr.material && spr.material.map) {
          spr.material.map = chooseGiftTexture();
          spr.material.needsUpdate = true;
        }
      }

      function chooseGiftTexture() {
        // 60% red, 40% green
        return Math.random() < 0.6 ? textures.gift : textures.giftGreen;
      }

      function handleTap(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        ndc.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        ndc.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(ndc, camera);
        const targets = [...giftSprites];
        if (fireplaceHit) targets.push(fireplaceHit);
        if (starMesh) targets.push(starMesh);
        if (santaSprite && santaSprite.visible) targets.push(santaSprite);
        const intersects = raycaster.intersectObjects(targets, false);
        if (intersects && intersects.length) {
          const hit = intersects[0].object;
          if (starMesh && hit === starMesh) {
            showGiftMessage("Kh√°nh ch√∫c b·∫°n gi√°ng sinh an l√†nh");
          } else if (santaSprite && hit === santaSprite) {
            playRandomSong(); // üéÖ ƒë·ªïi nh·∫°c random
          } else if (fireplaceHit && hit === fireplaceHit) {
            openDOBOverlay();
          } else if (giftSprites && giftSprites.includes(hit)) {
            // Make the clicked gift disappear briefly, then respawn above
            const spr = hit;
            spr.visible = false;
            setTimeout(() => {
              resetGift(spr, false);
              spr.visible = true;
            }, 2000);
            const text =
              MESSAGES && MESSAGES.length
                ? MESSAGES[Math.floor(Math.random() * MESSAGES.length)]
                : "Merry Christmas!";
            showGiftMessage(text);
          } else {
            const text =
              MESSAGES && MESSAGES.length
                ? MESSAGES[Math.floor(Math.random() * MESSAGES.length)]
                : "Merry Christmas!";
            showGiftMessage(text);
          }
        }
      }

      function updateParticleGroup(
        group,
        type,
        targetState,
        speed,
        time
      ) {
        const positions = group.geometry.attributes.position.array;
        const sizes = group.geometry.attributes.size.array;
        const colors = group.geometry.attributes.color.array;
        const phases = group.geometry.userData.phases;
        const baseColor = group.geometry.userData.baseColor;
        const baseSize = group.geometry.userData.baseSize;

        let targets;
        if (targetState === "TREE") targets = group.geometry.userData.tree;
        else if (targetState === "HEART") targets = group.geometry.userData.heart;
        else targets = group.geometry.userData.explode;

       
        for (let i = 0; i < positions.length; i++) {
          positions[i] += (targets[i] - positions[i]) * speed;
        }
        group.geometry.attributes.position.needsUpdate = true;

       
        const count = positions.length / 3;

        if (targetState === "TREE") {
          group.rotation.y = currentRotY;

          for (let i = 0; i < count; i++) {
            sizes[i] = baseSize;
            let brightness = 1.0;
            if (type === "red") {
              // RED
              brightness = 0.5 + 0.5 * Math.sin(time * 3 + phases[i]);
            } else if (type === "gold") {
              // YELLOW
              brightness = 0.8 + 0.4 * Math.sin(time * 10 + phases[i]);
            }
            colors[i * 3] = baseColor.r * brightness;
            colors[i * 3 + 1] = baseColor.g * brightness;
            colors[i * 3 + 2] = baseColor.b * brightness;
          }
          group.geometry.attributes.color.needsUpdate = true;
          group.geometry.attributes.size.needsUpdate = true;
        } else {
          group.scale.set(1, 1, 1);
          group.rotation.y = currentRotY;

          // size, color
          for (let i = 0; i < count; i++) {
            sizes[i] = baseSize;
            let brightness = 1.0;
            if (type === "gold" || type === "red") {
              brightness = 0.8 + 0.5 * Math.sin(time * 12 + phases[i]);
            }
            colors[i * 3] = baseColor.r * brightness;
            colors[i * 3 + 1] = baseColor.g * brightness;
            colors[i * 3 + 2] = baseColor.b * brightness;
          }
          group.geometry.attributes.size.needsUpdate = true;
          group.geometry.attributes.color.needsUpdate = true;
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const dt = lastTime ? time - lastTime : 0;
        lastTime = time;
        frameCounter++;
        // When the page is hidden, skip heavy work entirely
        if (document.hidden) {
          return;
        }
        const speed = 0.08;
        // FPS monitoring for dynamic performance adjustments
        if (dt > 0) {
          fpsAccum += 1 / dt;
          fpsCount++;
        }
        if (time - lastFpsAdjust > 2.0) {
          const avgFps = fpsCount ? fpsAccum / fpsCount : 60;
          fpsAccum = 0;
          fpsCount = 0;
          lastFpsAdjust = time;
          if (avgFps < 50 && currentPixelRatio > 1) {
            currentPixelRatio = Math.max(1, currentPixelRatio - 0.25);
            renderer.setPixelRatio(currentPixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.classList.add('lowperf');
          } else if (avgFps > 58 && currentPixelRatio < initialPixelRatio) {
            currentPixelRatio = Math.min(initialPixelRatio, currentPixelRatio + 0.25);
            renderer.setPixelRatio(currentPixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (currentPixelRatio === initialPixelRatio) {
              document.body.classList.remove('lowperf');
            }
          }
        }
        currentRotY += rotVelocity;
        rotVelocity *= 0.94;
        if (!isDragging && Math.abs(rotVelocity) < 0.0002) {
          rotVelocity = 0.003; // auto-rotate to the right when idle
        }
        updateParticleGroup(groupGold, "gold", state, speed, time);
        updateParticleGroup(groupRed, "red", state, speed, time);
        updateParticleGroup(groupGift, "gift", state, speed, time);

        photoMeshes.forEach((mesh, i) => {
          if (!mesh.material.map && photoTextures[i]) {
            mesh.material.map = photoTextures[i];
            mesh.material.needsUpdate = true;
          }
        });

        if (state === "TREE" || state === "HEART") {
          titleMesh.visible = true;
          starMesh.visible = true;
          titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
          starMesh.rotation.z -= 0.02;
          starMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 5);
          photoMeshes.forEach((m) => {
            m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            m.visible = false;
          });
        } else if (state === "EXPLODE") {
          titleMesh.visible = false;
          starMesh.visible = false;
          const baseAngle = groupGold.rotation.y;
          const angleStep = (Math.PI * 2) / 5;
          let bestIdx = 0;
          let maxZ = -999;
          photoMeshes.forEach((mesh, i) => {
            mesh.visible = true;
            const angle = baseAngle + i * angleStep;
            const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
            const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
            const y = Math.sin(time + i) * 3;
            mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
            mesh.lookAt(camera.position);
            if (z > maxZ) {
              maxZ = z;
              bestIdx = i;
            }
            if (z > 5) {
              const baseS = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.8;
              const mul = mesh.userData.scaleMul || 1.0;
              const ds = baseS * mul;
              mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
            } else {
              const mul = mesh.userData.scaleMul || 1.0;
              mesh.scale.lerp(new THREE.Vector3(0.6 * mul, 0.6 * mul, 0.6 * mul), 0.1);
            }
          });
          selectedIndex = bestIdx;
        } else if (state === "PHOTO") {
          photoMeshes.forEach((mesh, i) => {
            if (i === selectedIndex) {
              mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
              const mul = mesh.userData.scaleMul || 1.0;
              mesh.scale.lerp(new THREE.Vector3(5 * mul, 5 * mul, 5 * mul), 0.1);
              mesh.lookAt(camera.position);
              mesh.rotation.z = 0;
            } else {
              mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }
          });
        }
        const lowPerf = document.body.classList.contains('lowperf');
        const updateSnowThisFrame = !lowPerf || (frameCounter % 2 === 0);
        if (snowPoints && updateSnowThisFrame) {
          const pos = snowGeo.attributes.position.array;
          for (let i = 0; i < snowVelocities.length; i++) {
            pos[i * 3 + 1] -=
              snowVelocities[i] * (1 + 0.2 * Math.sin(time + i));
            pos[i * 3] += 0.05 * Math.sin(time * 0.5 + i);
            if (pos[i * 3 + 1] < -10) {
              pos[i * 3 + 1] = 110;
              pos[i * 3] = (Math.random() - 0.5) * 160;
              pos[i * 3 + 2] = (Math.random() - 0.5) * 160;
            }
          }
          snowGeo.attributes.position.needsUpdate = true;
        }
        if (flameSprite) {
          const pulse =
            1.0 + 0.08 * Math.sin(time * 8) + 0.04 * Math.sin(time * 13);
          flameSprite.scale.set(5 * pulse, 7 * pulse, 1);
          flameSprite.material.opacity =
            0.8 + 0.2 * Math.abs(Math.sin(time * 6));
        }
        // Santa spawn and movement
        if (santaSprite) {
          if (!santaActive) {
            nextSantaIn -= dt;
            if (nextSantaIn <= 0) {
              santaActive = true;
              santaSprite.visible = true;
              santaSprite.position.set(
                -90,
                18 + Math.random() * 18,
                -12 + Math.random() * 6
              );
              // even slower horizontal speed for a gentler fly-by
              santaSpeed = 0.08 + Math.random() * 0.12;
              santaPhase = Math.random() * Math.PI * 2;
            }
          } else {
            santaSprite.position.x += santaSpeed;
            const bobFreq = lowPerf ? 1.4 : 2.0;
            const bobAmp = lowPerf ? 0.4 : 0.6;
            const bob = Math.sin(time * bobFreq + santaPhase) * bobAmp;
            santaSprite.position.y += bob * dt * 60; // scale to frame rate-ish
            // slight tilt animation
            santaSprite.material.rotation =
              Math.sin(time * (lowPerf ? 1.1 : 1.5) + santaPhase) * 0.08;
            if (santaSprite.position.x > 90) {
              santaActive = false;
              santaSprite.visible = false;
              nextSantaIn = 8 + Math.random() * 14;
            }
          }
        }
        const updateGiftsThisFrame = !lowPerf || (frameCounter % 2 === 0);
        if (giftSprites && giftSprites.length && updateGiftsThisFrame) {
          for (let i = 0; i < giftSprites.length; i++) {
            const spr = giftSprites[i];
            spr.position.y -= giftVel[i] * (1 + 0.1 * Math.sin(time * 0.8 + i));
            spr.position.x += 0.05 * Math.sin(time * 0.7 + i);
            spr.material.rotation += lowPerf ? 0.006 : 0.01; // gentle spin
            if (spr.position.y < -8) resetGift(spr, false);
          }
        }
        renderer.render(scene, camera);
      }

      function startSystem() {
        document.getElementById("btnStart").style.display = "none";
        const preMsg = document.getElementById("preStart-msg");
        if (preMsg) preMsg.style.display = "none";
        userConsentedToAudio = true;
        // Beautify background after pressing START
        document.body.classList.add('started');
        // Lock visual height to avoid keyboard pushing content
        setAppHeight();
        applyDeviceProfile();
        init3D();
        // Lazy-load heavy photo textures after UI starts to render
        if ('requestIdleCallback' in window) {
          requestIdleCallback(loadPhotoTextures, { timeout: 2000 });
        } else {
          setTimeout(loadPhotoTextures, 0);
        }
        // Load playlist first, then auto-play a random song from it
        loadPlaylistFromFile()
          .then(() => {
            if (MUSIC_PLAYLIST.length > 0) {
              musicIndex = Math.floor(Math.random() * MUSIC_PLAYLIST.length);
              setAudioSource(MUSIC_PLAYLIST[musicIndex]);
              bgMusic.loop = true;
              bgMusic.play().catch(() => {});
            }
          })
          .catch((err) => {
            console.warn('Kh√¥ng th·ªÉ t·∫£i playlist:', err);
          });
        // Pause/resume music based on tab visibility
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            try {
              if (!bgMusic.paused) {
                pausedByVisibility = true;
                bgMusic.pause();
              }
            } catch {}
          } else {
            // Resume only if we paused due to visibility and user consented
            if (pausedByVisibility && userConsentedToAudio) {
              pausedByVisibility = false;
              bgMusic.play().catch(() => {});
            }
          }
        });
        // Mute toggle button logic
        const muteBtn = document.getElementById("mute-btn");
        const updateMuteIcon = () => {
          const v = bgMusic.muted || bgMusic.volume === 0 ? 0 : bgMusic.volume;
          if (v === 0) muteBtn.textContent = "üîá";
          else if (v < 0.35) muteBtn.textContent = "üîà";
          else if (v < 0.75) muteBtn.textContent = "üîâ";
          else muteBtn.textContent = "üîä";
        };
        updateMuteIcon();
        muteBtn.addEventListener("click", () => {
          // Toggle mute state; restore lastVolume when unmuting
          if (bgMusic.muted || bgMusic.volume === 0) {
            bgMusic.muted = false;
            const restore = lastVolume && lastVolume > 0 ? lastVolume : DEFAULT_VOLUME;
            bgMusic.volume = restore;
            const vs = document.getElementById("volume-slider");
            if (vs) vs.value = Math.round(restore * 100);
          } else {
            bgMusic.muted = true;
          }
          updateMuteIcon();
        });
        // Volume slider logic
        const volumeSlider = document.getElementById("volume-slider");
        if (volumeSlider) {
          volumeSlider.disabled = false;
          volumeSlider.value = Math.round(bgMusic.volume * 100);
          volumeSlider.addEventListener("input", () => {
            const v = Math.max(0, Math.min(100, Number(volumeSlider.value))) / 100;
            bgMusic.volume = v;
            if (v === 0) {
              bgMusic.muted = true;
            } else {
              bgMusic.muted = false;
              lastVolume = v;
            }
            updateMuteIcon();
          });
        }
        // Auto-resume playlist after Santa finishes
        bgMusic.addEventListener("ended", () => {
          if (isPlayingSanta) {
            isPlayingSanta = false;
            bgMusic.loop = true;
            // Play a random song from playlist
            if (MUSIC_PLAYLIST && MUSIC_PLAYLIST.length > 0) {
              playRandomSong();
            }
          }
        });
        const msg = document.getElementById("gift-message");
        const btnClose = document.getElementById("gift-close");
        btnClose.addEventListener("click", hideGiftMessage);
        msg.addEventListener("click", (e) => {
          if (e.target === msg) hideGiftMessage();
        });
        loadMessagesFromFile();

        const dob = document.getElementById("dob-overlay");
        const dobConfirm = document.getElementById("dob-confirm");
        const dobCancel = document.getElementById("dob-cancel");
        const dobInput = document.getElementById("dob-date");
        // Mark keyboard state to avoid renderer resize while typing
        if (dobInput) {
          dobInput.addEventListener('focus', () => {
            document.body.classList.add('keyboard-open');
          });
          dobInput.addEventListener('blur', () => {
            document.body.classList.remove('keyboard-open');
            setAppHeight();
            // Restore renderer size after keyboard hides
            if (camera && renderer) {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(window.innerWidth, window.innerHeight);
            }
          });
        }
        dobConfirm.addEventListener("click", () => {
          const input = document.getElementById("dob-date");
          const val = input.value; // t√™n ho·∫∑c ng√†y sinh
          if (!val) {
            showGiftMessage("Vui l√≤ng nh·∫≠p t√™n ho·∫∑c ng√†y sinh h·ª£p l·ªá.");
            return;
          }
          const trimmed = String(val).trim();
          // Chu·∫©n h√≥a ƒë·ªÉ kh√¥ng ph√¢n bi·ªát d·∫•u ti·∫øng Vi·ªát
          const normalized = trimmed.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
          // T·ª´ kh√≥a b√≠ m·∫≠t: 'Kh√°nh' ‚Üí h√¨nh tr√°i tim (ch·∫•p nh·∫≠n 'Kh√°nh' ho·∫∑c 'Khanh')
          if (normalized === "khanh") {
            triggerHeart(5000);
            closeDOBOverlay();
            showGiftMessage("Tr√°i tim Gi√°ng Sinh d√†nh cho b·∫°n! ‚ù§Ô∏è");
            return;
          }
          // N·∫øu l√† ng√†y (dd/mm) th√¨ d√πng l·ªùi ch√∫c theo ng√†y
          const parsed = parseDdMm(trimmed);
          if (parsed) {
            const msg = messageForDate(trimmed);
            closeDOBOverlay();
            if (parsed.dd === 25 && parsed.mm === 12) {
              playSantaSound();
              triggerTreeBurst(7000);
            }
            showGiftMessage(msg);
            return;
          }
          // Ng∆∞·ª£c l·∫°i, coi nh∆∞ t√™n v√† c√° nh√¢n h√≥a l·ªùi ch√∫c
          const msg = messageForName(trimmed);
          closeDOBOverlay();
          showGiftMessage(msg);
        });
        dobCancel.addEventListener("click", closeDOBOverlay);
        dob.addEventListener("click", (e) => {
          if (e.target === dob) closeDOBOverlay();
        });
      }

      function openDOBOverlay() {
        const dob = document.getElementById("dob-overlay");
        const input = document.getElementById("dob-date");
        input.value = "";
        dob.style.display = "flex";
        document.body.classList.add('modal-open');
      }

      function closeDOBOverlay() {
        const dob = document.getElementById("dob-overlay");
        dob.style.display = "none";
        document.body.classList.remove('modal-open');
        document.body.classList.remove('keyboard-open');
        setAppHeight();
      }

      function messageForDate(dmy) {
        try {
          const parsed = parseDdMm(dmy);
          if (!parsed)
            return MESSAGES && MESSAGES.length
              ? MESSAGES[0]
              : "Merry Christmas!";
          const { dUtc, year } = parsed;
          const start = Date.UTC(year, 0, 0);
          const day = Math.floor((dUtc - start) / 86400000); // 1..366
          if (MESSAGES && MESSAGES.length) {
            const idx = day % MESSAGES.length;
            return MESSAGES[idx];
          }
          return "Merry Christmas!";
        } catch (e) {
          return MESSAGES && MESSAGES.length ? MESSAGES[0] : "Merry Christmas!";
        }
      }
      function messageForName(name) {
        const n = String(name || "").trim();
        if (!n) return MESSAGES && MESSAGES.length ? MESSAGES[0] : "Merry Christmas!";
        const safe = n.replace(/[<>]/g, "");
        return `Gi√°ng Sinh vui v·∫ª, ${safe}!`;
      }

      function parseDdMm(s) {
        if (!s) return null;
        const cleaned = s
          .trim()
          .replace(/[\.\/-]/g, "/")
          .replace(/\s+/g, "");
        const parts = cleaned.split("/");
        if (parts.length !== 2) return null;
        const [ddStr, mmStr] = parts;
        const dd = parseInt(ddStr, 10);
        const mm = parseInt(mmStr, 10);
        if (!Number.isInteger(dd) || !Number.isInteger(mm)) return null;
        if (mm < 1 || mm > 12) return null;
        const yyyy = new Date().getFullYear();
        const dim = daysInMonth(mm, yyyy);
        if (dd < 1 || dd > dim) return null;
        const dUtc = Date.UTC(yyyy, mm - 1, dd);
        return { dUtc, year: yyyy, dd, mm };
      }

      function daysInMonth(m, y) {
        return new Date(y, m, 0).getDate();
      }

      function loadMessagesFromFile() {
        fetch("./greetings.txt")
          .then((r) => r.text())
          .then((txt) => {
            const lines = txt
              .split(/\r?\n/)
              .map((s) => s.replace(/^\uFEFF/, "").trim())
              .filter(Boolean);
            if (lines.length) {
              MESSAGES = lines;
            }
          })
          .catch((err) => {
            console.warn("Load greetings failed, using defaults:", err);
          });
      }

      function showGiftMessage(text) {
        const msg = document.getElementById("gift-message");
        const txt = document.getElementById("gift-text");
        txt.textContent = text;
        msg.style.display = "flex";
      }

      function hideGiftMessage() {
        const msg = document.getElementById("gift-message");
        msg.style.display = "none";
      }

      function setAppHeight() {
        const h = window.innerHeight;
        document.documentElement.style.setProperty('--app-height', h + 'px');
      }

      let _resizeTimer = null;
      window.addEventListener("resize", () => {
        // Ignore keyboard-induced resizes while typing
        if (document.body.classList.contains('keyboard-open')) return;
        if (_resizeTimer) clearTimeout(_resizeTimer);
        _resizeTimer = setTimeout(() => {
          setAppHeight();
          if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          }
        }, 120);
      });
    </script>
  </body>
</html>
